"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeadClickConfig = void 0;
const client_core_1 = require("@statsig/client-core");
const AutoCaptureEvent_1 = require("./AutoCaptureEvent");
const commonUtils_1 = require("./utils/commonUtils");
const eventUtils_1 = require("./utils/eventUtils");
const metadataUtils_1 = require("./utils/metadataUtils");
exports.DeadClickConfig = {
    CLICK_CHECK_TIMEOUT: 1000,
    SCROLL_DELAY_MS: 100,
    SELECTION_CHANGE_DELAY_MS: 100,
    MUTATION_DELAY_MS: 2500,
    ABSOLUTE_DEAD_CLICK_TIMEOUT: 2750,
};
// A dead click is a click that fires an event but produces no meaningful change within a set timeframe.
class DeadClickManager {
    constructor(_enqueueFn, _errorBoundary) {
        this._enqueueFn = _enqueueFn;
        this._errorBoundary = _errorBoundary;
        this._lastMutationTime = 0;
        this._lastSelectionChangeTime = 0;
        this._clicks = [];
        this._deadClickConfig = exports.DeadClickConfig;
        this._handleScroll = (0, commonUtils_1.throttle)(() => {
            const scrollTime = Date.now();
            this._clicks.forEach((click) => {
                if (!click.scrollDelayMs) {
                    click.scrollDelayMs = scrollTime - click.timestamp;
                }
            });
        }, 50);
    }
    startTracking() {
        try {
            const win = (0, client_core_1._getWindowSafe)();
            if (!win) {
                return;
            }
            // `capture: true` - Needed to listen to scroll events on all scrollable elements, not just the window.
            // docs: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#usecapture
            //
            // `passive: true` - Indicates the scroll handler wonâ€™t call preventDefault(),
            // allowing the browser to optimize scrolling performance by not blocking it.
            // docs: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#passive
            win.addEventListener('click', (event) => this._handleClick(event), {
                capture: true,
            });
            win.addEventListener('scroll', () => this._handleScroll(), {
                capture: true,
                passive: true,
            });
            win.addEventListener('selectionchange', () => this._handleSelectionChange());
            this._setupMutationObserver();
        }
        catch (error) {
            client_core_1.Log.error('Error starting dead click tracking', error);
            this._errorBoundary.logError('autoCapture:DeadClickManager', error);
        }
    }
    _handleClick(event) {
        var _a, _b;
        const eventTarget = event.target;
        if (!eventTarget) {
            return;
        }
        const click = {
            timestamp: Date.now(),
            eventTarget,
        };
        if (!commonUtils_1.interactiveElements.includes((_a = eventTarget === null || eventTarget === void 0 ? void 0 : eventTarget.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase())) {
            this._clicks.push(click);
        }
        if (this._clicks.length && !this._clickCheckTimer) {
            this._clickCheckTimer = (_b = (0, client_core_1._getWindowSafe)()) === null || _b === void 0 ? void 0 : _b.setTimeout(() => {
                this._checkForDeadClick();
            }, this._deadClickConfig.CLICK_CHECK_TIMEOUT);
        }
    }
    _handleSelectionChange() {
        this._lastSelectionChangeTime = Date.now();
    }
    _setupMutationObserver() {
        const doc = (0, client_core_1._getDocumentSafe)();
        if (!doc) {
            return;
        }
        this._observer = new MutationObserver(() => {
            this._lastMutationTime = Date.now();
        });
        this._observer.observe(doc.body, {
            childList: true,
            subtree: true,
            attributes: true,
            characterData: true,
        });
    }
    _checkForDeadClick() {
        var _a;
        if (!this._clicks.length) {
            return;
        }
        clearTimeout(this._clickCheckTimer);
        this._clickCheckTimer = undefined;
        const clicksToCheck = this._clicks;
        this._clicks = [];
        for (const click of clicksToCheck) {
            this._updateClickDelayMs(click);
            const hadScroll = click.scrollDelayMs != null &&
                click.scrollDelayMs < this._deadClickConfig.SCROLL_DELAY_MS;
            const hadSelectionChange = click.selectionChangeDelayMs != null &&
                click.selectionChangeDelayMs <
                    this._deadClickConfig.SELECTION_CHANGE_DELAY_MS;
            const hadMutation = click.mutationDelayMs != null &&
                click.mutationDelayMs < this._deadClickConfig.MUTATION_DELAY_MS;
            if (hadScroll || hadSelectionChange || hadMutation) {
                continue;
            }
            const scrollTimeout = click.scrollDelayMs != null &&
                click.scrollDelayMs > this._deadClickConfig.SCROLL_DELAY_MS;
            const selectionChangeTimeout = click.selectionChangeDelayMs != null &&
                click.selectionChangeDelayMs >
                    this._deadClickConfig.SELECTION_CHANGE_DELAY_MS;
            const mutationTimeout = click.mutationDelayMs != null &&
                click.mutationDelayMs > this._deadClickConfig.MUTATION_DELAY_MS;
            const absoluteTimeout = click.absoluteDelayMs != null &&
                click.absoluteDelayMs >
                    this._deadClickConfig.ABSOLUTE_DEAD_CLICK_TIMEOUT;
            if (scrollTimeout ||
                selectionChangeTimeout ||
                mutationTimeout ||
                absoluteTimeout) {
                this._logDeadClick(click, {
                    scrollTimeout,
                    selectionChangeTimeout,
                    mutationTimeout,
                    absoluteTimeout,
                });
            }
            else if (click.absoluteDelayMs != null &&
                click.absoluteDelayMs <
                    this._deadClickConfig.ABSOLUTE_DEAD_CLICK_TIMEOUT) {
                this._clicks.push(click);
            }
        }
        if (this._clicks.length && !this._clickCheckTimer) {
            this._clickCheckTimer = (_a = (0, client_core_1._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {
                this._checkForDeadClick();
            }, this._deadClickConfig.CLICK_CHECK_TIMEOUT);
        }
    }
    _logDeadClick(click, extraMetadata) {
        const { value, metadata } = (0, eventUtils_1._gatherEventData)(click.eventTarget);
        if (!value) {
            return;
        }
        this._enqueueFn(AutoCaptureEvent_1.AutoCaptureEventName.DEAD_CLICK, value, Object.assign(Object.assign(Object.assign(Object.assign({}, metadata), extraMetadata), (0, metadataUtils_1._gatherCommonMetadata)((0, commonUtils_1._getSafeUrl)())), { scrollDelayMs: click.scrollDelayMs, selectionChangeDelayMs: click.selectionChangeDelayMs, mutationDelayMs: click.mutationDelayMs, absoluteDelayMs: click.absoluteDelayMs }));
    }
    _updateClickDelayMs(click) {
        if (!click.mutationDelayMs &&
            this._lastMutationTime > 0 &&
            click.timestamp <= this._lastMutationTime) {
            click.mutationDelayMs = Date.now() - this._lastMutationTime;
        }
        if (!click.selectionChangeDelayMs &&
            this._lastSelectionChangeTime > 0 &&
            click.timestamp <= this._lastSelectionChangeTime) {
            click.selectionChangeDelayMs = Date.now() - this._lastSelectionChangeTime;
        }
        click.absoluteDelayMs = Date.now() - click.timestamp;
    }
}
exports.default = DeadClickManager;
